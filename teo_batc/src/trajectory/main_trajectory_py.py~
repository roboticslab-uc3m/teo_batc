#!/usr/bin/env python

import rospy
#from move_group_srv.srv import *
from teo_moveit.srv import *
from geometry_msgs.msg import PoseStamped
from std_msgs.msg import String
import numpy as np
import matplotlib.pyplot as plt
from scipy import interpolate
from trajectory_base_solution import *
from slerp import *
#from teo_moveit.srv import trajectory_gen_srv,trajectory_gen_srvResponse
#from teo_moveit.srv import move_group_srv

print("waiting for service")
rospy.wait_for_service('move_group_srv')
move_group_client = rospy.ServiceProxy('move_group_srv', move_group_srv)

def trajectory_gen(req):
    #If service ask me for a primitive, just exe or send primitive
    print("entre dentro del servicio")
    print req.i[0]
    if req.i[0]==0 or req.i[0]==1:
        p=PoseStamped()
        p.header.frame_id = "base_link"
        group_name= "right_arm"
        pos_tolerance= 0.01
        ang_tolerance= 0.1
        for t in np.arange(0,max_time,1): 
            p.pose.position.x = interpolate.splev(t,s_x[req.i[0]],der=0)
            p.pose.position.y = interpolate.splev(t,s_y[req.i[0]],der=0)
            p.pose.position.z = interpolate.splev(t,s_z[req.i[0]],der=0)
            p.pose.orientation.x = interpolate.splev(t,s_ox[req.i[0]],der=0)
            p.pose.orientation.y = interpolate.splev(t,s_oy[req.i[0]],der=0)
            p.pose.orientation.z = interpolate.splev(t,s_oz[req.i[0]],der=0)
            p.pose.orientation.w = interpolate.splev(t,s_ow[req.i[0]],der=0)
            #We call the service
            move_group_client(group_name, p, pos_tolerance, ang_tolerance)
            print(p)
    else:
        print("Voy a generar la nueva trayectoria")
        #First we call the base solution generation
        tf=[(pos_x2[-1]+pos_x1[-1])/2,(pos_y2[-1]+pos_y1[-1])/2,(pos_z2[-1]+pos_z1[-1])/2,(ori_x2[-1]+ori_x1[-1])/2,(ori_y2[-1]+ori_y1[-1]),(ori_z2[-1]+ori_z1[-1])/2,(ori_w2[-1]+ori_w1[-1])/2,0,0,0,0,0,0,0]
        #Define the list where we gonna save the trajectory
        pos_xf=[]
        pos_yf=[]
        pos_zf=[]
        ori_xf=[]
        ori_yf=[]
        ori_zf=[]
        ori_wf=[]
        (b_s,w1,w2)=base_trajectory_gen(tf)
        p=PoseStamped()
        p.header.frame_id = "base_link"
        group_name= "right_arm"
        pos_tolerance= 0.1
        ang_tolerance= 0.3
        for t in np.arange(0,max_time,1):
            #Weghted sum
            p.pose.position.x=interpolate.splev(t,s_x[b_s[0]],der=0)*w1+interpolate.splev(t,s_x[b_s[1]],der=0)*w2
            p.pose.position.y=interpolate.splev(t,s_y[b_s[0]],der=0)*w1+interpolate.splev(t,s_y[b_s[1]],der=0)*w2
            p.pose.position.z=interpolate.splev(t,s_z[b_s[0]],der=0)*w1+interpolate.splev(t,s_z[b_s[1]],der=0)*w2
            #p.pose.orientation.x=interpolate.splev(t,s_ox[b_s[0]],der=0)*w1+interpolate.splev(t,s_ox[b_s[1]],der=0)*w2
            #p.pose.orientation.y=interpolate.splev(t,s_oy[b_s[0]],der=0)*w1+interpolate.splev(t,s_oy[b_s[1]],der=0)*w2
            #p.pose.orientation.z=interpolate.splev(t,s_oz[b_s[0]],der=0)*w1+interpolate.splev(t,s_oz[b_s[1]],der=0)*w2
            #We fix w to the value that makes the unit quaternion
            #p.pose.orientation.w=1-(p.pose.orientation.x)**2-(p.pose.orientation.y)**2-(p.pose.orientation.z)**2
            #We use the funcion slerp to calculate the new quaternion

            p1=[ori_x1[t],ori_y1[t],ori_z1[t],ori_w1[t]]
            p2=[ori_x2[t],ori_y2[t],ori_z2[t],ori_w2[t]]
            print(p1)
            print(p2)
            p_ori=interp(p1,p2,w1)
            print(p_ori)
            p.pose.orientation.x=p_ori[0];
            p.pose.orientation.y=p_ori[1];
            p.pose.orientation.z=p_ori[2];
            p.pose.orientation.w=p_ori[3];
            #We call the servic
            move_group_client(group_name, p, pos_tolerance, ang_tolerance)
            print(p)
            pos_xf.append(p.pose.position.x)
            pos_yf.append(p.pose.position.y)
            pos_zf.append(p.pose.position.z)
            ori_xf.append(p.pose.orientation.x)
            ori_yf.append(p.pose.orientation.y)
            ori_zf.append(p.pose.orientation.z)
            ori_wf.append(p.pose.orientation.w)
    #Plot section (we plot the base trajectories and the result one)
    print(pos_x1)
    print(pos_x2)
    print(pos_xf)
    time=time_spline=np.arange(0,4,1)
    plt.figure()
    plt.plot(time,pos_x1,'o',time, pos_x2, 'x', time_spline,pos_xf)
    plt.axis([0, 3.5, -1, 1])
    plt.title('X trajectory spline interpolation')

    plt.figure()
    plt.plot(time,pos_y1,'o',time, pos_y2, 'x', time_spline,pos_yf)
    plt.axis([0, 3.5, -1, 1])
    plt.title('Y trajectory spline interpolation')

    plt.figure()
    plt.plot(time,pos_z1,'o',time, pos_z2, 'x', time_spline,pos_zf)
    plt.axis([0, 3.5, -1, 1])
    plt.title('Z trajectory spline interpolation')

    plt.figure()
    plt.plot(time,ori_x1,'o',time, ori_x2, 'x', time_spline,ori_xf)
    plt.axis([0, 3.5, -1, 1])
    plt.title('ORIX trajectory spline interpolation')

    plt.figure()
    plt.plot(time,ori_y1,'o',time, ori_y2, 'x', time_spline,ori_yf)
    plt.axis([0, 3.5, -1, 1])
    plt.title('oriy trajectory spline interpolation')

    plt.figure()
    plt.plot(time,ori_z1,'o',time, ori_z2, 'x', time_spline,ori_zf)
    plt.axis([0, 3.5, -1, 1])
    plt.title('oriz trajectory spline interpolation')

    plt.plot(time,ori_w1,'o',time, ori_w2, 'x', time_spline,ori_wf)
    plt.axis([0, 3.5, -1, 1])
    plt.title('oriw trajectory spline interpolation')
    plt.show()

    return trajectory_gen_srvResponse(True)

rospy.init_node('trajectory_gen_node')
s = rospy.Service('trajectory_gen', trajectory_gen_srv, trajectory_gen)
print "Trajectory gen READY"
rospy.spin()

